//Compute shader for generating a ssao texture
#version 430
#define SSAO_KERNELS 128

uniform sampler2D depthMap;
//Used to place the depthmap value in world space
uniform mat4 projMatrix;

const float near = 0.1;
const float far = 1500.0;

//SSAO kernels
uniform vec3 kernels[SSAO_KERNELS];

//Radius of the SSAO sphere
uniform float sampleRadius;

//Generalize this
vec2 screenSize = vec2(1280.f, 720.f);

//Output image position
layout(rgba32f, binding = 0) uniform writeonly image2D img_output;

vec3 normalFromDepth(float depth, vec2 coordinate);
vec4 positionFromDepth(float depth, vec2 samplePos);
//Compute shader layout
layout(local_size_x = 16, local_size_y = 16) in;
void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 samplePos = vec2(pixel_coords) / screenSize;
    float depth = texture(depthMap, samplePos).r;
    //Workgroup tile
    ivec2 tileID = ivec2(gl_WorkGroupID.xy);
    //Total number of work groups
    ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint tileIndex = tileID.y * tileNumber.x + tileID.x;
    depth = (2.0 * 0.1f) / (far + near - depth * (far - near));

    vec3 viewPosition = positionFromDepth(depth, samplePos).xyz;//Viewspace position

    float AO = 0.0f;

    for(int i = 0; i < SSAO_KERNELS; i++) {
        vec4 samplePos = vec4(viewPosition + normalize(kernels[i]), 1); //Get a random point as a vec4
        vec4 offset = projMatrix * samplePos; //Place the random point into clipspace
        offset.xy /= offset.w; //Perspective divide
        offset.xy = offset.xy * 0.5 + vec2(0.5); //[0, 1]

        float sampleDepth = positionFromDepth(depth, offset.xy).b;

        if (abs(viewPosition.z - sampleDepth) < sampleRadius) {
            AO += step(sampleDepth, samplePos.z);
        }
    }

    AO = 1.0 - AO/128.0;

    vec4 data = vec4(pow(AO, 2));//vec4(kernels[tileIndex % SSAO_KERNELS], 1);
    data  = vec4(normalFromDepth(depth, samplePos), 1);
    imageStore(img_output, ivec2(pixel_coords), data);
}

vec3 normalFromDepth(float depth, vec2 uv)
{
    vec2 offset1 = vec2( 0.0, 1.0 / screenSize.y);
    vec2 offset2 = vec2( 1.0 / screenSize.x, 0.0);

    float depth1 = texture(depthMap, uv + offset1).r;
    float depth2 = texture(depthMap, uv + offset2).r;

    vec3 p = positionFromDepth(depth, uv).xyz;
    vec3 p1 = positionFromDepth(depth1, uv + offset1).xyz;
    vec3 p2 = positionFromDepth(depth2, uv + offset2).xyz;

    vec3 v1 = p1 - p;
    vec3 v2 = p2 - p;

    vec3 normal = cross(v1, v2);
    normal.z = -normal.z;

    return normalize(normal) * 0.5 + 0.5;
}

vec4 positionFromDepth(float depth, vec2 samplePos) {
    float x = samplePos.x * 2 - 1;
    float y = (1 - samplePos.y) * 2 - 1;
    vec4 projectedPos = vec4(x, y, depth, 1.0);
    vec4 viewPosition = inverse(projMatrix) * projectedPos;
    return (viewPosition / viewPosition.w);
    //Convert a depthmap pixel to a vec4 position
    //Get the clipspace position
    /*vec4 clipPosition = vec4(samplePos * 2.0 - 1.0, depth, 1.0);    //[-1, 1] = X & Y
    vec4 viewPosition = inverse(projMatrix) * clipPosition;
    viewPosition /= viewPosition.w;
    vec4 worldPosition = inverse(viewMatrix) * viewPosition;
    return viewPosition;*/
}
